前言感悟：
不同语言原生支持的数据结构不同，像java原生就支持数组，链表，散列等数据结构，数组在内存存储上表现为一片
连续的空间每一个数据单元占据的内存空间大小是相等的，所以可以根据地址的偏移对数据实现快速访问，但是当需要
插入或删除一个元素的时候，则需要对目标元素之后的所有元素进行位置的移动了，开销较大。而链表数据结构本质是
根据引用（地址指针）维护与相邻节点的关系，在存储上不一定是连续的，删除某个节点需要重置其相邻节点的prev或
next指向地址即可，所以你删除节点的开销不会很大，但如果想获得链表中某个节点的值，需要从链表的头结点开始遍历
直到找到需要的节点。在前端开发中语言原生没有这些数据结构，我们用javascript数组来模拟各种数据结构从存储结构
本质上来考量是没有太大意义的,但我们在实际开发中对于数据结构的选择更多的是一种业务场景上的考虑，所以说也可以
使用。很多时候我们需要对数据进行快存快取（比如redis等各种缓存组件），并用key来标记自己存取的数据，我们可以把
它叫做key-value的结构，说到快速我们立马想到数组，因为数组可以在0(1)的时间复杂内完成指定位置元素的读写操作。
所以在理想状态下存在一个函数（hash函数）可以将每一个key映射到唯一的一个数组下标，就可以完美的解决问题。


散列表：
散列是一种常用的数据存储技术，散列后的数据可以快速插入或使用，散列使用的数据结构叫做散列表。在散列表进行
插入、删除和取用数据都非常快。但是对于查找操作来讲效率比较低下，这需要求助于其他数据结构比如说二叉树就是
一个很好的选择。
我们的散列表是基于数组进行设计的，数组的长度是预先设定的，如有需要可以随时增加。所有元素根据和该元素对应
的键保存在数组的特定位置，该键和我们前面讲到的字典中的键是类似的概念。使用散列表存储数据时，通过一个散列
函数将键映射为一个数字，这个数字的范围是0到散列表的长度。理想情况下，散列函数会将每个键值映射为一个唯一的
数组索引。然而键的数量是无限的，数组的长度是有限的，一个更显示的目标是让散列函数尽量将键均匀映射到数组中。
即使使用一个高效的散列函数，仍然存在将两个键映射成同一个值的可能，这种现象称为碰撞

