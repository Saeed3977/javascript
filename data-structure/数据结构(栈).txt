定义：
栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称之为栈。咖啡厅内的
一摞盘子是现实世界中常见的栈的例子。只能从最上面取盘子，盘子洗干净后也只能摞在这
一摞盘子的最上面。栈被称为一种后入先出的数据结构。
由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。为了得到栈底的元素，
必须先拿掉上面的元素。对栈的两种主要操作时将一个元素压入栈和将一个元素弹出栈。
入栈使用push()方法，出栈使用pop()方法。另一个常用的操作是预览栈顶的元素。pop()
方法虽然可以访问栈顶的元素，但是调用该方法后栈顶元素也就永久被删除了。peek()方法
则只返回栈顶的元素，而不删除。为了记录栈顶元素的位置，同时也为了标记哪里可以加入
新元素，我们使用变量top，当向栈内压入元素时，该变量增大，从栈内弹出元素时，该变量
减小。
栈的概念和实现它的内部数据结构是完全分开的

function Stack(){
	this.dataStore = [];
	this.top = 0;
	this.push = push;
	this.pop = pop;
	this.peek = peek;
}

function push(element){
	this.dataStore[this.top++] = element;
}

function pop(){
	//最顶层元素其实没有删除，但在概念上已经不存在因为top已变
	return this.dataStore[--this.top];
}

function peek(){
	return this.dataStore[this.top - 1];
}

function length(){
	return this.top;
}

function clear(){
	this.top = 0;
}

function isEmpty(){
	return this.top == 0;
}

/*
	//回文或者倒序
	function isPalindrome(word){
		var s = new Stack(), rword = '';
		for(var i=0; i<word.length; i++){
			s.push(word[i]);
		}
		while(s.length() > 0){
			rword += s.pop();
		}
		word == rword ? return true : return false;
	}
	
	//使用栈模拟递归
	function fact(n){
		var s = new Stack(), product = 1;
		while(n > 1){
			s.push(n--);
		}
		while(s.length() > 0){
			product *= s.pop();
		}
		return product;
	}
	
	//分隔符匹配
	var checkStack = new Stack();
	for(var i=0; i<strArr.length; i++){
		var item = strArr[i];
		if(/[\{\}\[\]\(\)]/g.test(item)){
			switch(item){
				case '{': 
				case '[':
				case '(':
					checkStack.push(item); break;
				case '}':
				case ']':
				case ')':
					if(!checkStack.isEmpty()){
						var checkItem = checkStack.pop();
						if((item == '}' && checkItem !== '{') || (item == ']' && checkItem !== '[') || (item == ')' && checkItem !== '(')){
							console.log('error at match ' + item);
						}
					}
					break;
			}
		}
	}
	
*/