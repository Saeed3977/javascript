职责链模式：
对于一个请求，多个对象都可以处理该请求，但是到底哪个对象要处理该请求在开发期是不确定的，也就是说请求的发送者和接收者是
一种动态的关系。所以需要将这些对象链成一条链，并沿着这条链传递该请求，链上的对象要么处理该请求，要么传递给下一个对象，从
而避免了请求的发送者和接受者之间的耦合关系。

流程：
1.发送者知道链中的第一个接受者，它向这个接受者发送请求；
2.链中的接受者对该请求进行分析，然后要么处理该请求要么传递给下一个对象;
3.每个接受者知道的其他对象只有一个，那就是它在链中的下家;
4.如果没有任何接受者处理该请求，那么请求将从链中离开，不同的实现对此也有不同的反应，一般会抛出一个错误。

适用场合：
若事先不知道在几个对象中有哪些能够处理请求，那么就属于应该适用职责链的情况；
若这批处理器对象在开发期间不可知，而是需要动态指定的话，那么也应该使用这种模式；
该模式还可以用在对于每个请求都不止有一个对象可以对它进行处理的情况；
使用这种模式可以把特定的具体类与客户端隔离开，并代之以一条有弱耦合对象组成的链，它将隐式地对请求进行处理，这有助于提高代码的
模块程度和可维护性。

//section1
图书馆示例，实现几种目录对象，以便按不同标准对图书进行分类。发送者是图书，接收者是分类。图书馆知道第一个接收者firstGenreCatalog,
addBook添加图书时，直接调用第一个接收者分类接口。第一个接收者判断该图片是否属于自己这一类，属于则将该图书添加到本类中。然后再
调用下一个接收者分类接口，以此类推，一个一个接收者处理下去，直到没有下一个接收者。
var PublicLibrary = function(books,firstGenreCatalog){
	this.catalog = {};
	this.firstGenreCatalog = firstGenreCatalog;
	for(var i=0,len=books.length; i<len; i++){
		this.addBook(books[i]);
	}
};
PublicLibrary.prototype = {
	addBook: function(book){
		this.catalog[book.getIsbn()] = {
			book: book,
			available: true
		};
		this.firstGenreCatalog.handleFillingRequest(book);
	},
	findBook: function(book){
		var target = this.catalog[book.getIsbn()];
		if(target){
			return target;
		}
		return 'not found the book';
	},
	returnBook: function(){},
	checkoutBook: function(){}
};

var GenreCatalog = function(nextCatalog){
	this.catalog = [];
	this.nextCatalog = nextCatalog;
};
GenreCatalog.prototype = {
	_bookMatch: function(){}
	handlerFillingRequest: function(book){
		if(this._bookMatch(book)){
			this.catalog.push(book);
		}
		if(this.nextCatalog){
			this.nextCatalog.handlerFillingRequest(book);
		}
	}
};

var nextCatalog = function(){
	GenreCatalog.apply(this,arguments);
};
nextCatalog.prototype = {
	_bookMatch: function(){},
	handlerFillingRequest: function(){
		//...
	}
};

//section2:
职责链模式经常和组合模式一起使用，这样可以在现有层次体系中实现这种模式往往更加
容易，因为组合模式已经建立了一个对象层次体系，因此在此基础上添加一些用来处理（或者传递）请求的方法很简单。在组合模式结合了
职责链之后，方法调用就不再总是不加分辨地往下一直传递到叶子对象。此时每一层都要对请求进行分析，以判断当前位置的对象应该处理
它还是应该把它往下传递。组合对象实际上也会承担部分工作，而不是单纯依靠叶对象执行所有操作。这样一来就不用单独实现一些对象来
作为链上的环节，也不用手工设定下家对象。职责链模式和组合模式的结合对双方都是一种优化。由于职责链是现成的对于组合模式来讲，
所以设置代码的数量和用于职责链的额外对象的数目都减少了。由于组合层次体系中某个方法可能会在高层得到处理，所以在整个树上执行
方法所需的计算量也降低了。DOM里面的事件冒泡机制也有类似的地方（不论在捕获还是冒泡阶段，每一级Dom都可以停止事件传播也可以让其
继续沿着层级体系向上或向下传播）。其实在express框架中的中间件connect实现上也可以看做是采用了职责链模式.

职责链模式之利：
借助于职责链模式，可以动态选择由哪个对象处理请求，这意味着你可以使用只有在运行期间才能知道的条件来把任务分配给最恰当的对象。
还可以使用这个模式消除发出请求的对象与处理请求的对象之间的耦合。藉此你可以在模块的组织方面获得更大的灵活性，而且在重构和修改
代码的时候不用担心会把类名固化在算法中。
职责链模式之弊：
由于在职责链模式中，请求与具体的处理程序被隔离开来，因为无法保证它一定会被处理，而不是径直从链尾离开。这种模式的接收者是隐式的，
因此无法得知如果请求能够得到处理的话具体由哪个对象处理。
