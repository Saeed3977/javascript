中介者模式：mediator
中介者模式是一个行为设计模式，使我们可以导出统一的接口，这样系统不同部分就可以彼此通信。
如果系统组件之间存在大量的直接关系，那不同组件间的关系就过于杂乱不可维护（如机场塔台存在）
且有些场景下需要权限访问控制及错误处理机制，这就可能是时候使用一个中心的控制点，来让不同
的组件通过它进行通信。中介者模式通过将组件之间显示或直接的引用替换成通过中心点来交互的方
式做到松散耦合，这样可以帮助我们解耦和改善组件的重用性，这其实也是中央集权的控制中心特征。
雅虎前端工程师提到过一种可伸缩的javascript架构（scalable javascript application architecture），
见图mediator.png,在这种架构模型中中介者无非是整个架构的核心模式。

在本系列中我写过观察者模式的一个实际产品案例，这里重复下
S.MQ = {
		_handlers: {},
		_topics: function(topics){
			return topics.indexOf(',') == -1 ? [topics] : topics.replace(/\s/g,function(){return '';}).split(',');
		},
		_topicExist: function(topic){
			if(this._handlers.hasOwnProperty(topic) && this.handlers[topic].length > 0){
				return true;
			}
			return;
		},
		_each: function(array,processor){
			var item;
			for(var i=0,len=array.length; i<len; i++){
				item = array[i];
				processor(item,i);
			}
		},
		sub: function(topic,handler){
			var me = this;
			this._each(me._topics(topic),function(item,i){
				if(me._topicExist(item)){
					me._handlers[item].push(handler);
				}
				else{
					me._handlers[item] = [handler];
				}
			});
		},
		pub: function(topic,data){
			var me = this;
			this._each(this._topics(topic),function(topic){
				if(this._topicExist(topic)){
					me._each(me._handlers[topic],function(handler){
						handler({topic:topic,data:data});
					});
				}
				else{
					log('the topic' + topic + 'is not exist');
				}
			});
		},
		unsub: function(topic,handler){
			var me = this;
			this._each(this._topics(topic),function(topic){
				if(me._topicExist(topic)){
					me._each(me._handlers[topic],function(item,i){
						if(item == handler){
							me._handlers[topic].splice(i,1);
						}
					});
				}
				else{
					log('the topic' + topic + 'is not exist');
				}
			});
		},
		hasSub: function(topic){
			return this._topicExist(topic);
		}
	};
	
	其实将这个案例放在观察者模式中是不恰当的现在看来，而是应该作为中介者模式的案例。我们可以回顾下观察者模式的定义是一个被称作被观察者的对象，
	维护一组被称为观察者的对象，这些对象依赖于被观察者，被观察者自动将自身的状态的任何变化通知给他们。当被观察者
	需要将一些变化通知给观察者的时候，它将采用广播的方式，这条广播可能包含特定于这条通知的一些数据（这里由于具体
	通知数据的不同我们又可以将观察者模式划分为推和拉两种模型）。比如小明妈妈叫小明回家吃饭的例子，在观察者模式中被
	观察者是明确知道观察者的存在且可以直接调用的，这是单向的，常见是一对多的模式。
	而飞机通信的场景中，飞机之间是存在互相观察和被观察的关系的，并不是单向的，况且大部分情况下是多对多的关系，那这种
	场景下还是用观察者模式就显得非常杂乱无序
