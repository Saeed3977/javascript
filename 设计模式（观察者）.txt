/*
	Observe：观察者模式
	它是这样一种设计模式，一个被称作被观察者的对象，维护一组被称为观察者的对象，这些对象依赖于被观察者
	被观察者自动将自身的状态的任何变化通知给他们。当被观察者需要将一些变化通知给观察者的时候，它将采用广播的
	方式，这条广播可能包含特定于这条通知的一些数据。当特定的观察者不需要接收它所注册的被观察者的通知的时候，
	被观察者可以将其从所维护的组中删除
*/

	//section1: javascript中的发布/订阅模式
	在javascript中我们通常使用pub/sub来实现观察者模式，在nodejs中已经在语言层面支持这种模式（也可以叫做事件机制）
	但其与观察者模式还是有写区别的：
	1.pub/sub模式是基于一个事件/主题来作为观察者与被观察者沟通的桥梁
	2.这个事件/主题允许定义应用相关的事件，该事件可以传递特殊参数，参数中包含订阅者所需的值
	3.很好的解耦订阅者和发布者
	
	//section2:产品中的实现
	S.MQ = {
		_handlers: {},
		_topics: function(topics){
			return topics.indexOf(',') == -1 ? [topics] : topics.replace(/\s/g,function(){return '';}).split(',');
		},
		_topicExist: function(topic){
			if(this._handlers.hasOwnProperty(topic) && this.handlers[topic].length > 0){
				return true;
			}
			return;
		},
		_each: function(array,processor){
			var item;
			for(var i=0,len=array.length; i<len; i++){
				item = array[i];
				processor(item,i);
			}
		},
		sub: function(topic,handler){
			var me = this;
			this._each(me._topics(topic),function(item,i){
				if(me._topicExist(item)){
					me._handlers[item].push(handler);
				}
				else{
					me._handlers[item] = [handler];
				}
			});
		},
		pub: function(topic,data){
			var me = this;
			this._each(this._topics(topic),function(topic){
				if(this._topicExist(topic)){
					me._each(me._handlers[topic],function(handler){
						handler({topic:topic,data:data});
					});
				}
				else{
					log('the topic' + topic + 'is not exist');
				}
			});
		},
		unsub: function(topic,handler){
			var me = this;
			this._each(this._topics(topic),function(topic){
				if(me._topicExist(topic)){
					me._each(me._handlers[topic],function(item,i){
						if(item == handler){
							me._handlers[topic].splice(i,1);
						}
					});
				}
				else{
					log('the topic' + topic + 'is not exist');
				}
			});
		},
		hasSub: function(topic){
			return this._topicExist(topic);
		}
	};
	
	//section3:注意点
	上述是在全局作用域中，在实际应用中我们可能会再次封装，pub/sub可能处于不同的上下文，则sub要事先绑定handler的context
	具体实现可参见$.proxy,大致如下：
	var proxy = (function(handler,context){
		return function(){
			handler.apply(context,arguments);
		};
	})();
	